# Orchestral

> **Orchestral** 是一个 Rust 原生、以 **Intent → Plan → DAG Execution** 为核心范式的 Agent Runtime。
>
> **Orchestral** is a Rust-native, **intent-first agent runtime** that plans, orchestrates, and executes dynamic DAGs generated by LLMs.
>
> 它面向真实业务场景，强调 **动态规划、引用解析、多模态执行、可恢复工作流**，而非静态流程编排。
>
> It is designed for real-world products, focusing on **dynamic planning, reference resolution, multimodal actions, and resumable workflows**, rather than static workflows.

---

## 1. 设计目标（Design Goals）

### 1.1 核心目标（Core Goals）

* **Intent-first**：以用户意图为第一等公民，而不是预定义流程
  Treat user intent as the first-class input, not predefined workflows.

* **Planner-driven**：由 LLM 动态生成执行计划（Plan）
  Execution plans are generated dynamically by LLMs.

* **Plan as Asset**：Plan 是系统的核心中间产物，而非 Graph
  Plans are the primary asset; graphs are a transient execution form.

* **Business-grade Runtime**：支持追问续传、失败恢复、状态持久化
  Built for production with resumable workflows and durable state.

* **Multimodal-native**：文本、图像、文档等能力是一等能力
  Text, image, and document actions are first-class citizens.

### 1.2 明确不做的事情（Non-Goals）

* ❌ 不提供 DSL / Workflow Editor
  No DSL or visual workflow editor.

* ❌ 不追求全局强类型状态建模
  No attempt to fully strongly-type global state.

* ❌ 不绑定特定 LLM / 云厂商
  No hard dependency on a specific LLM or provider.

---

## 2. 核心概念模型（Core Concepts）

### 2.1 整体架构（High-Level Architecture）

```
User Input
   ↓
Intent Understanding
   ↓
Planner (LLM)
   ↓
Plan (DAG Description)
   ↓
Plan Normalizer & Validator
   ↓
Executor
   ↓
Actions
   ↓
SSE / Result
```

### 2.2 关键概念定义（Key Concepts）

#### Intent（意图）

* 用户在当前上下文中的目标描述
  A high-level description of what the user wants to achieve.

#### Plan（计划）

* LLM 生成的 **粗粒度 DAG 描述**
  A coarse-grained DAG describing *what* to do and *in what dependency order*.

#### Action（动作）

* 原子执行单元，对 Executor 是黑盒
  Atomic execution unit, treated as a black box by the executor.

#### Executor（执行器）

* 负责 DAG 的调度与执行
  Responsible for scheduling and executing the DAG.

---

## 3. Planner 设计（Planner Design）

### 3.1 Planner 职责边界（Responsibilities）

Planner **只负责“做什么”**：

* 识别用户意图
* 选择 Action
* 构建依赖关系

Planner **不负责**：

* 参数展开细节
* 并行 / 重试策略
* 执行期错误恢复

> Planner decides *what to do*, never *how to execute*.

### 3.2 Plan Schema（输出约束）

Planner 输出必须满足：

* DAG 无环（Acyclic）
* Action 名称必须存在
* 所有依赖节点必须已定义

```json
{
  "goal": "Edit the previous image",
  "steps": [
    {"id": "s1", "action": "resolve_reference", "depends_on": []},
    {"id": "s2", "action": "image_edit", "depends_on": ["s1"]}
  ]
}
```

---

## 4. Plan Normalizer（稳定性核心）

> **Plan Normalizer 是 Orchestral 的稳定性中枢，而不是可选组件。**
>
> The Plan Normalizer is the stability core of Orchestral.

### 4.1 职责（Responsibilities）

* 校验 Plan 合法性
  Validate plan correctness.

* 补全隐式步骤（如 resolve_reference）
  Inject implicit steps when necessary.

* 修复常见 LLM 规划错误
  Repair common LLM planning errors.

* 生成可执行 DAG
  Produce an executable DAG for the executor.

---

## 5. Executor 设计（Executor Design）

### 5.1 执行模型（Execution Model）

* 基于 DAG 的拓扑调度
  DAG-based topological scheduling.

* 支持 **多个 ready 节点并行执行**（当前目标）
  Parallel execution of ready nodes (current goal).

* 执行状态驱动
  Execution is state-driven.

### 5.2 任务状态机（Task State Machine）

```
PLANNING
  ↓
EXECUTING
  ↓
WAITING_USER
  ↓
DONE
```

WAITING_USER 表示系统明确知道“还缺什么信息”。
WAITING_USER means the system explicitly knows what input is missing.

---

## 6. Action 设计（Action Design）

### 6.1 Action 抽象（Action Abstraction）

```rust
trait Action {
    fn name(&self) -> &str;
    fn run(&self, input: ActionInput, ctx: ActionContext) -> ActionResult;
}
```

### 6.2 Action 设计原则（Principles）

* Executor 不理解 Action 语义
  Executor is semantics-agnostic.

* Action 内部可以包含子流程
  Actions may internally contain sub-steps.

---

## 7. 数据流模型（Data Flow Model）

### 7.1 workingSet

* 弱类型 KV 数据容器
  Weakly-typed key-value data store.

* 用于节点间通信
  Used for inter-step communication.

### 7.2 显式数据契约（当前目标）

* 每个 Step 声明：

  * `exports`
  * `imports`

This reduces hidden dependencies without enforcing strong typing.

---

## 8. 引用解析（Reference Resolution）

### 8.1 设计动机（Motivation）

* 显式建模自然语言指代（"that image", "previous file"）
  Explicit modeling of natural language references.

* 降低 Planner 与 Action 的复杂度
  Reduce planner and action complexity.

### 8.2 Reference Store

* 统一管理历史产物
  Centralized storage for past artifacts.

* 支持时间 / 类型 / 相似度检索
  Supports time-, type-, and similarity-based lookup.

---

## 9. 状态持久化与恢复（State & Recovery）

### 9.1 Task Store

* Redis / KV Store
* 持久化内容：

  * Task 状态
  * Plan
  * workingSet
  * references

### 9.2 追问续传（Clarification Resume）

* WAITING_USER 后用户回复可：

  * 重新 Planner
  * 或从 Executor 继续

---

## 10. 当前版本目标（Current Roadmap as Goals）

> 以下内容 **不是未来设想，而是当前版本必须达成的目标**。

* ✅ 稳定的 Planner → Plan → Executor 主流程
* ✅ Plan Normalizer（校验 + 修复）
* ✅ 并行 ready node 执行
* ✅ 显式 Step import / export 数据契约
* ✅ Composite Action（Action 内子 DAG）
* ✅ 可观测性（Execution Timeline / Trace）

---

## 11. Crate 结构建议（Crate Layout）

```
orchestral-core
  ├── planner
  ├── plan
  ├── normalizer
  ├── executor
  ├── action
  ├── store
  └── types
```

---

## 12. 一句话定义（One-liner）

> **Orchestral** is a Rust-native, intent-first agent runtime that transforms user intent into executable plans and orchestrates them as dynamic DAGs — reliably, resumably, and at scale.
