version: 1

app:
  name: orchestral-cli
  environment: development

runtime:
  max_interactions_per_thread: 10
  auto_cleanup: true
  concurrency_policy: interrupt_and_start_new
  strict_imports: true
  strict_exports: true

planner:
  mode: llm
  # Requires GEMINI_API_KEY (or switch to deterministic mode for offline testing).
  backend: google
  model_profile: gemini-3-flash
  max_history: 20
  dynamic_model_selection: true

context:
  history_limit: 50
  max_tokens: 4096
  include_history: true
  include_references: true

stores:
  # For quick local testing in a single process.
  # If you need cross-process persistence, switch backend to redis and add connection_url.
  event:
    backend: in_memory
  task:
    backend: in_memory
  reference:
    backend: in_memory

observability:
  log_level: info
  traces_enabled: false

providers:
  default_backend: openai
  default_model: fast
  backends:
    - name: openai
      kind: openai
      api_key_env: OPENAI_API_KEY
      config:
        timeout_secs: 30
    - name: google
      kind: google
      api_key_env: GEMINI_API_KEY
      config:
        timeout_secs: 60
  models:
    - name: fast
      backend: openai
      model: gpt-4o-mini
      temperature: 0.2
      system_prompt: |
        You are the planning engine for Orchestral.
        Generate executable plans only.
      policy:
        temperature_min: 0.0
        temperature_max: 1.0
    - name: deep
      backend: openai
      model: gpt-4.1
      temperature: 0.1
      policy:
        temperature_min: 0.0
        temperature_max: 0.7
    - name: gemini-3-flash
      backend: google
      model: gemini-3-flash-preview
      temperature: 0.2
      system_prompt: |
        You are the planning engine for Orchestral.
        Your job is to transform user intent into an executable DAG plan.

        Hard requirements:
        - Output JSON only. No markdown, no prose, no code fences.
        - Use only actions from the Action Catalog provided at runtime.
        - Prefer the smallest valid DAG that satisfies the goal.
        - Step IDs must be stable and unique (s1, s2, ...).
        - Respect action contracts:
          - step.params must satisfy each action's input_schema.
          - action outputs are validated against output_schema.
        - For cross-step data flow, declare io_bindings.
        - If information is missing, use a wait_user step to ask for clarification.
        - kind/depends_on/exports are optional for normal action steps and can be omitted.
          Only set kind explicitly for wait_user/wait_event/system steps.

        Plan shape reminder:
        {
          "goal": "...",
          "steps": [
            {
              "id": "s1",
              "action": "action_name",
              "params": {},
              "io_bindings": [{"from":"s1.key","to":"target_key","required":true}]
            }
          ],
          "confidence": 0.0
        }

      policy:
        temperature_min: 0.0
        temperature_max: 1.0

actions:
  hot_reload: true
  actions:
    - name: echo
      kind: echo
      description: "Echoes input back as output"
      interface:
        input_schema:
          type: object
          properties:
            message:
              type: string
          required: ["message"]
        output_schema:
          type: object
          properties:
            result:
              type: string
          required: ["result"]
      config:
        prefix: "Echo: "
    - name: http
      kind: http
      description: "Performs an HTTP request"
      interface:
        input_schema:
          type: object
          properties:
            method:
              type: string
            url:
              type: string
            headers:
              type: object
            body: {}
            json: {}
        output_schema:
          type: object
          properties:
            status:
              type: integer
            url:
              type: string
            headers:
              type: object
            body:
              type: string
          required: ["status", "url", "headers", "body"]
      config:
        default_method: "GET"
        timeout_ms: 10000
    - name: shell
      kind: shell
      description: "Runs a shell command"
      interface:
        input_schema:
          type: object
          properties:
            command:
              type: string
            args:
              type: array
              items:
                type: string
          required: ["command"]
        output_schema:
          type: object
          properties:
            stdout:
              type: string
            stderr:
              type: string
            status:
              type: integer
          required: ["stdout", "stderr", "status"]
      config:
        timeout_ms: 10000
    - name: file_read
      kind: file_read
      description: "Reads a file from disk"
      interface:
        input_schema:
          type: object
          properties:
            path:
              type: string
          required: ["path"]
        output_schema:
          type: object
          properties:
            content:
              type: string
            path:
              type: string
          required: ["content", "path"]
      config:
        root_dir: "."
    - name: file_write
      kind: file_write
      description: "Writes a file to disk"
      interface:
        input_schema:
          type: object
          properties:
            path:
              type: string
            content:
              type: string
            append:
              type: boolean
          required: ["path", "content"]
        output_schema:
          type: object
          properties:
            path:
              type: string
            bytes:
              type: integer
          required: ["path", "bytes"]
      config:
        root_dir: "."
        create_dirs: true
