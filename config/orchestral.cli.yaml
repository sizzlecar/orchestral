version: 1

app:
  name: orchestral-cli
  environment: development

runtime:
  max_interactions_per_thread: 10
  auto_cleanup: true
  concurrency_policy: interrupt_and_start_new
  strict_imports: true
  strict_exports: true

planner:
  mode: llm
  # Requires GEMINI_API_KEY (or switch to deterministic mode for offline testing).
  backend: google
  model_profile: gemini-3-flash
  max_history: 20
  dynamic_model_selection: true

context:
  history_limit: 50
  max_tokens: 4096
  include_history: true
  include_references: true

stores:
  # For quick local testing in a single process.
  # If you need cross-process persistence, switch backend to redis and add connection_url.
  event:
    backend: in_memory
  task:
    backend: in_memory
  reference:
    backend: in_memory

observability:
  log_level: info
  traces_enabled: false

providers:
  default_backend: openai
  default_model: fast
  backends:
    - name: openai
      kind: openai
      api_key_env: OPENAI_API_KEY
      config:
        timeout_secs: 30
    - name: google
      kind: google
      api_key_env: GEMINI_API_KEY
      config:
        timeout_secs: 60
  models:
    - name: fast
      backend: openai
      model: gpt-4o-mini
      temperature: 0.2
      system_prompt: |
        You are the planning engine for Orchestral.
        Generate executable plans only.
      policy:
        temperature_min: 0.0
        temperature_max: 1.0
    - name: deep
      backend: openai
      model: gpt-4.1
      temperature: 0.1
      policy:
        temperature_min: 0.0
        temperature_max: 0.7
    - name: gemini-3-flash
      backend: google
      model: gemini-3-flash-preview
      temperature: 0.2
      system_prompt: |
        You are the planning engine for Orchestral.
        Your job is to transform user intent into an executable DAG plan.

        Hard requirements:
        - Output JSON only. No markdown, no prose, no code fences.
        - Use only actions from the Action Catalog provided at runtime.
        - Prefer the smallest valid DAG that satisfies the goal.
        - Step IDs must be stable and unique (s1, s2, ...).
        - Respect action contracts:
          - step.params must satisfy each action's input_schema.
          - action outputs are validated against output_schema.
        - For cross-step data flow, declare io_bindings.
        - If information is missing, use a wait_user step to ask for clarification.
        - kind/depends_on/exports are optional for normal action steps and can be omitted.
          Only set kind explicitly for wait_user/wait_event/system steps.

        Plan shape reminder:
        {
          "goal": "...",
          "steps": [
            {
              "id": "s1",
              "action": "action_name",
              "params": {},
              "io_bindings": [{"from":"s1.key","to":"target_key","required":true}]
            }
          ],
          "confidence": 0.0
        }

      policy:
        temperature_min: 0.0
        temperature_max: 1.0

actions:
  hot_reload: true
  # Optional: external process action (multi-language plugin) example:
  # - name: echo_external
  #   kind: external_process
  #   description: "Echo via Python plugin"
  #   interface:
  #     input_schema:
  #       type: object
  #       properties:
  #         message:
  #           type: string
  #       required: ["message"]
  #     output_schema:
  #       type: object
  #       properties:
  #         result:
  #           type: string
  #       required: ["result"]
  #   config:
  #     command: "python3"
  #     args: ["examples/plugins/echo_plugin.py"]
  #     timeout_ms: 10000
  actions:
    - name: echo
      kind: echo
      description: "Echoes input back as output"
      interface:
        input_schema:
          type: object
          properties:
            message:
              type: string
              description: "Text to echo back."
              example: "hello orchestral"
          required: ["message"]
        output_schema:
          type: object
          properties:
            result:
              type: string
              description: "Echoed text result."
              example: "Echo: hello orchestral"
          required: ["result"]
      config:
        prefix: "Echo: "
    - name: http
      kind: http
      description: "Performs an HTTP request"
      interface:
        input_schema:
          type: object
          properties:
            method:
              type: string
              description: "HTTP method."
              default: "GET"
              example: "GET"
            url:
              type: string
              description: "Request URL."
              example: "https://www.google.com"
            headers:
              type: object
              description: "Optional request headers."
            body: {}
            json: {}
          required: ["url"]
        output_schema:
          type: object
          properties:
            status:
              type: integer
              description: "HTTP status code."
              example: 200
            url:
              type: string
              description: "Resolved request URL."
            headers:
              type: object
              description: "Response headers."
            body:
              type: string
              description: "Response body as text."
          required: ["status", "url", "headers", "body"]
      config:
        default_method: "GET"
        timeout_ms: 10000
    - name: shell
      kind: shell
      description: "Runs a shell command"
      interface:
        input_schema:
          type: object
          properties:
            command:
              type: string
              description: "Executable name or shell command string."
              example: "ls"
            args:
              type: array
              description: "Optional arguments. If missing, command runs via sh -c."
              items:
                type: string
              example: ["-la"]
            shell:
              type: boolean
              description: "Whether to execute command as a shell expression (`sh -c`)."
          required: ["command"]
        output_schema:
          type: object
          properties:
            stdout:
              type: string
              description: "Captured stdout."
            stderr:
              type: string
              description: "Captured stderr."
            status:
              type: integer
              description: "Process exit status code."
            timed_out:
              type: boolean
              description: "Whether process timed out and was killed."
            stdout_truncated:
              type: boolean
              description: "Whether stdout exceeded max_output_bytes."
            stderr_truncated:
              type: boolean
              description: "Whether stderr exceeded max_output_bytes."
          required: ["stdout", "stderr", "status", "timed_out", "stdout_truncated", "stderr_truncated"]
      config:
        timeout_ms: 10000
        allow_shell_expression: false
        max_output_bytes: 65536
        blocked_commands: ["rm", "mkfs", "shutdown", "reboot", "poweroff"]
    - name: file_read
      kind: file_read
      description: "Reads a file from disk"
      interface:
        input_schema:
          type: object
          properties:
            path:
              type: string
              description: "File path to read (must stay under root_dir)."
              example: "docs/readme.md"
            max_bytes:
              type: integer
              description: "Read at most this many bytes."
            truncate:
              type: boolean
              description: "When true, oversize files are truncated."
          required: ["path"]
        output_schema:
          type: object
          properties:
            content:
              type: string
              description: "File content as UTF-8 text."
            path:
              type: string
              description: "Resolved absolute path."
            bytes:
              type: integer
              description: "Returned content bytes."
            truncated:
              type: boolean
              description: "Whether content was truncated."
          required: ["content", "path", "bytes", "truncated"]
      config:
        root_dir: "."
        max_read_bytes: 524288
    - name: file_write
      kind: file_write
      description: "Writes a file to disk"
      interface:
        input_schema:
          type: object
          properties:
            path:
              type: string
              description: "Target file path to write (must stay under root_dir)."
              example: "output/google.html"
            content:
              type: string
              description: "Text content to write."
            append:
              type: boolean
              description: "Append instead of overwrite."
              default: false
            max_bytes:
              type: integer
              description: "Maximum bytes allowed for content in this call."
          required: ["path", "content"]
        output_schema:
          type: object
          properties:
            path:
              type: string
              description: "Resolved absolute path."
            bytes:
              type: integer
              description: "Bytes written to file."
          required: ["path", "bytes"]
      config:
        root_dir: "."
        create_dirs: true
        max_write_bytes: 524288
