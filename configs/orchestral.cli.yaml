version: 1

app:
  name: orchestral-cli
  environment: development

runtime:
  max_interactions_per_thread: 10
  auto_cleanup: true
  concurrency_policy: interrupt_and_start_new
  strict_exports: true

planner:
  mode: llm
  # Requires GEMINI_API_KEY (or switch to deterministic mode for offline testing).
  backend: google
  model_profile: gemini-3-flash
  max_history: 20
  dynamic_model_selection: true

interpreter:
  mode: llm
  backend: google
  model_profile: gemini-2.5-flash
  temperature: 0.0

context:
  history_limit: 50
  max_tokens: 4096
  include_history: true
  include_references: true

stores:
  # For quick local testing in a single process.
  # If you need cross-process persistence, switch backend to redis and add connection_url.
  event:
    backend: in_memory
  task:
    backend: in_memory
  reference:
    backend: in_memory

observability:
  log_level: info
  traces_enabled: false
  # Runtime logs are persisted by default for easier debugging.
  # Can be overridden by ORCHESTRAL_LOG_FILE.
  log_file: "logs/orchestral-runtime.log"

providers:
  default_backend: openai
  default_model: fast
  backends:
    - name: openai
      kind: openai
      api_key_env: OPENAI_API_KEY
      config:
        timeout_secs: 30
    - name: google
      kind: google
      api_key_env: GEMINI_API_KEY
      config:
        timeout_secs: 60
        interpreter_timeout_secs: 8
  models:
    - name: fast
      backend: openai
      model: gpt-4o-mini
      temperature: 0.2
      system_prompt: |
        You are the planning engine for Orchestral.
        Generate executable plans only.
      policy:
        temperature_min: 0.0
        temperature_max: 1.0
    - name: deep
      backend: openai
      model: gpt-4.1
      temperature: 0.1
      policy:
        temperature_min: 0.0
        temperature_max: 0.7
    - name: gemini-3-flash
      backend: google
      model: gemini-3-flash-preview
      temperature: 0.2
      system_prompt: |
        You are the planning engine for Orchestral.
        Your job is to transform user intent into an executable DAG plan.

        Hard requirements:
        - Output JSON only. No markdown, no prose, no code fences.
        - Use only actions from the Action Catalog provided at runtime.
        - Prefer the smallest valid DAG that satisfies the goal.
        - Step IDs must be stable and unique (s1, s2, ...).
        - Respect action contracts:
          - step.params must satisfy each action's input_schema.
          - action outputs are validated against output_schema.
        - For cross-step data flow, declare io_bindings.
        - If information is missing, use a wait_user step to ask for clarification.
        - kind/depends_on/exports are optional for normal action steps and can be omitted.
          Only set kind explicitly for wait_user/wait_event/system steps.

        Plan shape reminder:
        {
          "goal": "...",
          "steps": [
            {
              "id": "s1",
              "action": "action_name",
              "params": {},
              "io_bindings": [{"from":"s1.key","to":"target_key","required":true}]
            }
          ],
          "confidence": 0.0
        }
      policy:
        temperature_min: 0.0
        temperature_max: 1.0
    - name: gemini-2.5-flash
      backend: google
      model: gemini-2.5-flash
      temperature: 0.2
actions:
  hot_reload: true
  # Optional: external process action (multi-language plugin) example:
  # - name: echo_external
  #   kind: external_process
  #   description: "Echo via Python plugin"
  #   interface:
  #     input_schema:
  #       type: object
  #       properties:
  #         message:
  #           type: string
  #       required: ["message"]
  #     output_schema:
  #       type: object
  #       properties:
  #         result:
  #           type: string
  #       required: ["result"]
  #   config:
  #     command: "python3"
  #     args: ["examples/plugins/echo_plugin.py"]
  #     timeout_ms: 10000
  actions:
    - name: echo
      kind: echo
      description: "Echoes input back as output"
      interface:
        input_schema:
          type: object
          properties:
            message:
              type: string
              description: "Text to echo back."
              example: "hello orchestral"
          required: ["message"]
        output_schema:
          type: object
          properties:
            result:
              type: string
              description: "Echoed text result."
              example: "Echo: hello orchestral"
          required: ["result"]
      config:
        prefix: "Echo: "
    - name: doc_parse
      kind: external_process
      description: "Parse document with markitdown and return structure"
      interface:
        input_schema:
          type: object
          properties:
            source_path:
              type: string
              description: "Local document path to parse."
              example: "docs/spec.pdf"
          required: ["source_path"]
        output_schema:
          type: object
          properties:
            source_path:
              type: string
            markdown:
              type: string
            headings:
              type: array
              items:
                type: object
                properties:
                  line:
                    type: integer
                  level:
                    type: integer
                  title:
                    type: string
            word_count:
              type: integer
            char_count:
              type: integer
          required: ["source_path", "markdown", "headings", "word_count", "char_count"]
      config:
        command: "/Users/chejinxuan/rust_ws/orchestral/.venv/bin/python"
        args: ["examples/plugins/markitdown_plugin.py"]
        entrypoint: "doc_parse"
        timeout_ms: 180000
    - name: doc_convert
      kind: external_process
      description: "Pandoc document conversion/generation tool. It can: (1) convert source files between formats (docx/pdf/html/md/txt, etc.) using mode=convert + to_format; (2) generate markdown summary/outline/overview from source files using mode=summary|outline|overview; (3) optionally write result to target_path or return inline text when target_path is omitted. Note: markdown/md/gfm outputs are normalized to gfm-raw_html by default to avoid raw HTML blocks and pandoc-specific markdown syntax."
      interface:
        input_schema:
          type: object
          properties:
            source_path:
              type: string
              description: "Required local source file path. Use existing workspace file paths."
              example: "docs/spec.docx"
            mode:
              type: string
              description: "Operation mode. convert = direct pandoc conversion; summary/outline/overview = generate markdown artifacts from parsed source content."
              default: "convert"
            from_format:
              type: string
              description: "Optional pandoc --from format (for ambiguous inputs). Example: docx, markdown, html."
              example: "docx"
            to_format:
              type: string
              description: "Target format for mode=convert (pandoc --to). Common values: markdown, html, plain, gfm. markdown/md/gfm are normalized to gfm-raw_html unless explicitly overridden."
              default: "gfm-raw_html"
              example: "gfm-raw_html"
            target_path:
              type: string
              description: "Optional output file path. If provided, writes file and returns metadata; if omitted in convert mode, returns converted content inline."
              example: "output/spec.md"
            summary_sentences:
              type: integer
              description: "Used by summary/overview mode to control summary length."
              default: 5
            extra_args:
              type: array
              description: "Optional extra pandoc CLI args for advanced conversion behavior, e.g. ['--standalone']."
              items:
                type: string
          required: ["source_path"]
        output_schema:
          type: object
          properties:
            source_path:
              type: string
              description: "Original source file path."
            mode:
              type: string
              description: "Executed mode: convert/summary/outline/overview."
            from_format:
              type: ["string", "null"]
              description: "Resolved input format hint."
            to_format:
              type: string
              description: "Output format used by conversion."
            target_path:
              type: ["string", "null"]
              description: "Output file path when writing to disk."
            wrote_file:
              type: boolean
              description: "True if target_path was written."
            bytes:
              type: ["integer", "null"]
              description: "Written file size in bytes when wrote_file=true."
            content:
              type: string
              description: "Inline converted content for mode=convert when not writing to file."
            generated_markdown:
              type: string
              description: "Generated markdown text for mode=summary|outline|overview."
            pandoc_command:
              type: string
              description: "Pandoc command used for execution (for debugging/traceability)."
          required: ["source_path", "mode", "to_format", "target_path", "wrote_file", "pandoc_command"]
      config:
        command: "/Users/chejinxuan/rust_ws/orchestral/.venv/bin/python"
        args: ["examples/plugins/pandoc_plugin.py"]
        entrypoint: "doc_convert"
        timeout_ms: 180000
    - name: http
      kind: http
      description: "Performs an HTTP request"
      interface:
        input_schema:
          type: object
          properties:
            method:
              type: string
              description: "HTTP method."
              default: "GET"
              example: "GET"
            url:
              type: string
              description: "Request URL."
              example: "https://www.google.com"
            headers:
              type: object
              description: "Optional request headers."
            body: {}
            json: {}
          required: ["url"]
        output_schema:
          type: object
          properties:
            status:
              type: integer
              description: "HTTP status code."
              example: 200
            url:
              type: string
              description: "Resolved request URL."
            headers:
              type: object
              description: "Response headers."
            body:
              type: string
              description: "Response body as text."
          required: ["status", "url", "headers", "body"]
      config:
        default_method: "GET"
        timeout_ms: 10000
    - name: shell
      kind: shell
      description: "Runs a shell command"
      interface:
        input_schema:
          type: object
          properties:
            command:
              type: string
              description: "Executable name or shell command string."
              example: "ls"
            args:
              type: array
              description: "Optional arguments. If missing, command runs via sh -c."
              items:
                type: string
              example: ["-la"]
            shell:
              type: boolean
              description: "Whether to execute command as a shell expression (`sh -c`)."
            sandbox_mode:
              type: string
              description: "Optional override: none/read_only/workspace_write."
            sandbox_backend:
              type: string
              description: "Optional override: auto/macos_seatbelt/linux_seccomp/windows_restricted."
          required: ["command"]
        output_schema:
          type: object
          properties:
            stdout:
              type: string
              description: "Captured stdout."
            stderr:
              type: string
              description: "Captured stderr."
            status:
              type: integer
              description: "Process exit status code."
            timed_out:
              type: boolean
              description: "Whether process timed out and was killed."
            stdout_truncated:
              type: boolean
              description: "Whether stdout exceeded max_output_bytes."
            stderr_truncated:
              type: boolean
              description: "Whether stderr exceeded max_output_bytes."
            sandbox_mode:
              type: string
              description: "Applied sandbox mode."
            sandboxed:
              type: boolean
              description: "Whether command ran with OS sandbox wrapper."
            sandbox_backend:
              type: string
              description: "Resolved sandbox backend name."
            env_policy:
              type: string
              description: "Applied environment policy."
          required: ["stdout", "stderr", "status", "timed_out", "stdout_truncated", "stderr_truncated", "sandbox_mode", "sandboxed", "sandbox_backend", "env_policy"]
      config:
        timeout_ms: 10000
        allow_shell_expression: false
        max_output_bytes: 65536
        sandbox_mode: workspace_write
        sandbox_backend: auto
        sandbox_allow_network: false
        # Linux only (optional): explicit bubblewrap executable path.
        # sandbox_linux_bwrap_path: "/usr/bin/bwrap"
        sandbox_writable_roots: ["."]
        env_policy: minimal
        env_denylist: ["OPENAI_API_KEY", "GEMINI_API_KEY", "HF_TOKEN"]
        blocked_commands: ["mkfs", "shutdown", "reboot", "poweroff"]
    - name: file_read
      kind: file_read
      description: "Reads a file from disk"
      interface:
        input_schema:
          type: object
          properties:
            path:
              type: string
              description: "File path to read (must stay under sandbox_writable_roots when sandbox is enabled)."
              example: "docs/readme.md"
            max_bytes:
              type: integer
              description: "Read at most this many bytes."
            truncate:
              type: boolean
              description: "When true, oversize files are truncated."
          required: ["path"]
        output_schema:
          type: object
          properties:
            content:
              type: string
              description: "File content as UTF-8 text."
            path:
              type: string
              description: "Resolved absolute path."
            bytes:
              type: integer
              description: "Returned content bytes."
            truncated:
              type: boolean
              description: "Whether content was truncated."
          required: ["content", "path", "bytes", "truncated"]
      config:
        sandbox_mode: workspace_write
        sandbox_writable_roots: ["."]
        max_read_bytes: 524288
    - name: file_write
      kind: file_write
      description: "Writes a file to disk"
      interface:
        input_schema:
          type: object
          properties:
            path:
              type: string
              description: "Target file path to write (must stay under sandbox_writable_roots when sandbox is enabled)."
              example: "output/google.html"
            content:
              type: string
              description: "Text content to write."
            append:
              type: boolean
              description: "Append instead of overwrite."
              default: false
            max_bytes:
              type: integer
              description: "Maximum bytes allowed for content in this call."
          required: ["path", "content"]
        output_schema:
          type: object
          properties:
            path:
              type: string
              description: "Resolved absolute path."
            bytes:
              type: integer
              description: "Bytes written to file."
          required: ["path", "bytes"]
      config:
        sandbox_mode: workspace_write
        sandbox_writable_roots: ["."]
        create_dirs: true
        max_write_bytes: 524288
